% PostScript Library
% Plotter ProcSet
% written and copyright (c) 2006 by Andreas Zoellner

/Plotter <<
  /XScreenLeft 0
  /YScreenBottom 482
  /XScreenRight 480
  /YScreenTop 842
  /X0 -1
  /Y0 -1

  /GetFontSize 10

  /SolidLine { [] 0 setdash }
  /DashedLine { [4 8] 2 setdash }
  /DottedLine { [1 4] 2 setdash }

  /Init { % --
    0 setgray 0.5 setlinewidth SolidLine
    XScreenLeft YScreenBottom XScreenRight YScreenTop SetScreen
    XCoordsLeft YCoordsBottom XCoordsRight YCoordsTop SetCoords
    (Helvetica) GetFontSize SetFont
  }

  /SetScreen { % llx lly urx ury --
    4 1 roll exch 4 -1 roll
    2 copy gt {exch} if
    4 2 roll
    2 copy gt {exch} if
    4 2 roll

    /YScreenTop exch def
    /YScreenBottom exch def
    /XScreenRight exch def
    /XScreenLeft exch def

    ClearScreen
    %CalcOrigin
  }

  /ScreenWidth { % -- width
    XScreenRight XScreenLeft sub
  }

  /ScreenHeight { % -- height
    YScreenTop YScreenBottom sub
  }

  /ClearScreen { % --
    XScreenLeft YScreenBottom
    ScreenWidth ScreenHeight
    4 copy
    gsave
      1 setgray
      rectfill
    grestore
    rectclip
  }

  /Frame { % --
    XScreenLeft YScreenBottom
    ScreenWidth ScreenHeight
    gsave
      0 setgray 1 setlinewidth SolidLine
      rectstroke
    grestore
  }

  /XCoordsLeft -1.0
  /YCoordsBottom 1.0
  /XCoordsRight -1.0
  /YCoordsTop 1.0
  /Inf 2.0
  /-Inf -2.0

  /SetCoords { % llx lly urx ury --
    /YCoordsTop exch def
    /XCoordsRight exch def
    /YCoordsBottom exch def
    /XCoordsLeft exch def
    XCoordsLeft XCoordsRight eq {
      XCoordsLeft dup
      1 sub /XCoordsLeft exch def
      1 add /XCoordsRight exch def
    } if
    YCoordsBottom YCoordsTop eq {
      YCoordsBottom dup
      1 sub /YCoordsBottom exch def
      1 add /YCoordsTop exch def
    } if
    [XCoordsLeft XCoordsRight YCoordsBottom YCoordsTop] dup
    AMin 1 sub /-Inf exch def
    AMax 1 add /Inf exch def
    %CalcOrigin
  }

  /CalcOrigin { % --
    0 0 CoordsToScreen
    dup YScreenBottom lt {pop YScreenBottom} if
    dup YScreenTop gt {pop YScreenTop} if
    /Y0 exch def
    dup XScreenLeft lt {pop XScreenLeft} if
    dup XScreenRight gt {pop XScreenRight} if
    /X0 exch def
  }

  /XToScreen { % cx -- sx
    XCoordsLeft sub
    ScreenWidth mul
    XCoordsRight XCoordsLeft sub div
    XScreenLeft add
  }

  /YToScreen { % cy -- sy
    YCoordsBottom sub
    ScreenHeight mul
    YCoordsTop YCoordsBottom sub div
    YScreenBottom add
  }

  /CoordsToScreen { % cx cy -- sx sy
    YToScreen
    exch
    XToScreen
    exch
  }

  /ScreenToCoords { % sx sy -- cx cy
    YScreenBottom sub
    YCoordsTop YCoordsBottom sub mul
    ScreenHeight div
    YCoordsBottom add
    exch
    XScreenLeft sub
    XCoordsRight XCoordsLeft sub mul
    ScreenWidth div
    XCoordsLeft add
    exch
  }

  /Min { 2 copy gt {exch} if pop } % num1 num2 -- num
  /Max { 2 copy lt {exch} if pop } % num1 num2 -- num
  /Sgn { 0 gt {1} {-1} ifelse }  % num -- num

  /AMin { % array -- integer
    dup 0 get exch
    {Min} forall
  }
  /AMax { % array -- integer
    dup 0 get exch
    {Max} forall
  }

  /Axes { % --
    CalcOrigin
    gsave
      0 setgray 1 setlinewidth SolidLine
      newpath XScreenLeft Y0 moveto XScreenRight Y0 lineto stroke
      newpath X0 YScreenBottom moveto X0 YScreenTop lineto stroke
      newpath
        XCoordsLeft XCoordsRight Max XToScreen Y0 moveto currentlinewidth dup neg dup 6 mul XCoordsRight XCoordsLeft sub Sgn mul exch rlineto
        2 mul 0 exch rlineto
        closepath stroke
      newpath
        X0 YScreenBottom YScreenTop Max moveto currentlinewidth dup neg dup 6 mul YCoordsTop YCoordsBottom sub Sgn mul rlineto
        2 mul 0 rlineto
        closepath stroke
    grestore
  }

  /XLabel { % string|array --
    CalcOrigin
    /Offset 10 def
    gsave
      0 setgray 1 setlinewidth SolidLine
      dup StringSize
      newpath
        XCoordsLeft XCoordsRight Max XToScreen Y0 moveto
        Offset add neg /dY exch def
        /dX exch def
        gsave
          dX dY rmoveto
          currentpoint
          YScreenBottom lt {/dY dY neg Offset sub def} if
          XScreenRight gt {dX Offset add neg} {Offset} ifelse /dX exch def
        grestore
        dX dY rmoveto
        /Show /show load def
      dup type /stringtype eq {Show} {{exec} forall} ifelse
    grestore
  }

  /YLabel { % string|array --
    CalcOrigin
    /Offset 10 def
    gsave
      0 setgray 1 setlinewidth SolidLine
      dup StringSize
      newpath
        X0 YCoordsBottom YCoordsTop Max YToScreen moveto
        Offset add neg /dY exch def
        Offset add neg /dX exch def
        gsave
          dX dY rmoveto
          currentpoint
          YScreenBottom lt {/dY dY neg Offset sub def} if
          XScreenLeft lt {/dX Offset def} if
        grestore
        dX dY rmoveto
        /Show /show load def
      dup type /stringtype eq {Show} {{exec} forall} ifelse
    grestore
  }

  /XTicks { % array --
    CalcOrigin
    /TickLength 5 def
    gsave
      0 setgray 1 setlinewidth SolidLine
      {
        newpath
          XToScreen Y0 TickLength sub moveto
          0 TickLength 2 mul rlineto
        stroke
      } forall
    grestore
  }

  /YTicks { % array --
    CalcOrigin
    /TickLength 5 def
    gsave
      0 setgray 1 setlinewidth SolidLine
      {
        newpath
          YToScreen X0 TickLength sub exch moveto
          TickLength 2 mul 0 rlineto
        stroke
      } forall
    grestore
  }

  /Grid { % xarray yarray --
    gsave
      0.5 setgray 0.5 setlinewidth DashedLine
      {
        newpath
          YToScreen XScreenLeft exch moveto
          ScreenWidth 0 rlineto
        stroke
      } forall
      {
        newpath
          XToScreen YScreenBottom moveto
          0 ScreenHeight rlineto
        stroke
      } forall
    grestore
  }

  /ForallX{ % function --
    XCoordsLeft
    XCoordsRight XCoordsLeft sub ScreenWidth div
    XCoordsRight
    4 -1 roll for
  }

  /ForallX*{ % function Factor --
    XCoordsRight XCoordsLeft sub ScreenWidth div mul
    XCoordsLeft exch
    XCoordsRight
    4 -1 roll for
  }

  /ForallY{ % function --
    YCoordsBottom
    YCoordsTop YCoordsBottom sub ScreenHeight div
    YCoordsTop
    4 -1 roll for
  }

  /ForallY*{ % function Factor --
    YCoordsTop YCoordsBottom sub ScreenHeight div mul
    YCoordsBottom exch
    YCoordsTop
    4 -1 roll for
  }

  /Plot { % function --
    /Function exch def
    % 0 0 1 setrgbcolor 1 setlinewidth SolidLine
    newpath
      XCoordsLeft dup Function CoordsToScreen moveto
      {
        dup Function CoordsToScreen lineto
      } 0.5 ForallX*
    stroke
  }

  /NewPlot { % function --
    /Function exch def
    /dX XCoordsRight XCoordsLeft sub ScreenWidth div abs def
    /dY YCoordsTop YCoordsBottom sub ScreenHeight div abs def
    XCoordsLeft XCoordsRight le {
      /X0 XCoordsLeft def /X1 XCoordsRight def
    } {
      /X1 XCoordsLeft def /X0 XCoordsRight def
    } ifelse
    /X X0 def
    % 0 0 1 setrgbcolor 1 setlinewidth SolidLine
    newpath
      X dup Function dup /Y exch def CoordsToScreen moveto
      {
        /Xn X dX add def
        Xn Function /Yn exch def
        Yn Y sub abs dY div dup 1 gt {
          dX exch div X add /Xn exch def
          Xn Function /Yn exch def
        } {
          pop
        } ifelse
        /X Xn def /Y Yn def
        X Y CoordsToScreen lineto
        X X1 ge {exit} if
      } loop
    stroke
  }

  /PlotDiscontinuous { % function YTolerance --
    /YTolerance exch def
    /Function exch def
    /Discontinue {currentpoint stroke moveto DashedLine lineto currentpoint stroke moveto SolidLine} bind def
      % alternatively: /Discontinue /moveto load def
    % 0 0 1 setrgbcolor 1 setlinewidth SolidLine
    newpath
      XCoordsLeft dup Function CoordsToScreen dup /Yold exch def moveto
      {
        dup Function CoordsToScreen dup /Ynew exch def
        Ynew Yold sub abs YTolerance gt {Discontinue} {lineto} ifelse
        /Yold Ynew def
      } 0.5 ForallX*
    stroke
  }

  /CurrentPoint { % -- cx cy
    currentpoint ScreenToCoords
  }

  /MoveTo { % cx cy --
    CoordsToScreen moveto
  }

  /RMoveTo { % cx cy --
    CoordsToScreen 0 YToScreen sub exch 0 XToScreen sub exch rmoveto
  }

  /LineTo { % cx cy --
    CoordsToScreen lineto
  }

  /RLineTo { % cx cy --
    CoordsToScreen 0 YToScreen sub exch 0 XToScreen sub exch rlineto
  }

  /Line { % xa ya xb yb --
    CoordsToScreen 4 2 roll CoordsToScreen 4 2 roll
    newpath moveto lineto stroke
  }

  /Rectangle { % xa ya xb yb --
    CoordsToScreen 4 2 roll CoordsToScreen 4 2 roll
    4 1 roll exch 4 -1 roll
    2 copy gt {exch} if 4 2 roll
    2 copy gt {exch} if 4 2 roll

    1 index sub 4 2 roll
    1 index sub 4 2 roll
    4 1 roll exch 4 -1 roll
    newpath rectstroke
  }

  /Ellipse { % xa ya xb yb --
    CoordsToScreen 4 2 roll CoordsToScreen 4 2 roll
    4 1 roll exch 4 -1 roll
    2 copy sub abs 2 div /Ry exch def
    4 2 roll
    2 copy sub abs 2 div /Rx exch def
    4 2 roll
    add 2 div /My exch def
    add 2 div /Mx exch def
    newpath
    Mx Rx add My moveto
    0 1 360 {
      /Phi exch def
      Mx Rx Phi cos mul add
      My Ry Phi sin mul add
      lineto
    } for
    stroke
  }

  /Circle { % xm ym xr --
    XToScreen 0 XToScreen sub abs 3 1 roll
    CoordsToScreen
    2 copy exch 4 index add exch
    newpath
      moveto 3 -1 roll 0 360 arc
    stroke
  }

  /FillCircle { % xm ym xr --
    XToScreen 0 XToScreen sub abs 3 1 roll
    CoordsToScreen
    2 copy exch 4 index add exch
    newpath
      moveto 3 -1 roll 0 360 arc fill
    stroke
  }

  /NGon { % n cx cy r phi0 --
    /Phi exch def
    XToScreen 0 XToScreen sub abs /R exch def
    CoordsToScreen /Cy exch def /Cx exch def
    round /N exch def
    N 3 ge {
      newpath
        Phi cos R mul Cx add Phi sin R mul Cy add moveto
        Phi 360 N div 360 Phi add {
          dup cos R mul Cx add exch sin R mul Cy add lineto
        } for
        closepath
      stroke
    } if
  }

  /Pixel { % x y --
    CoordsToScreen
    gsave
      1 setlinewidth SolidLine
      newpath 1 1 rectstroke
    grestore
  }

  /SetGray { % r --
    dup 0 lt {
      pop 0
    }
    {
      dup 1 gt {
        pop 1
      } if
    } ifelse
    setgray
  }

  /ISOLatin1 {findfont dup length dict begin {1 index /FID ne {def} {pop pop} ifelse} forall /Encoding ISOLatin1Encoding def currentdict end /ThisFont exch definefont pop /ThisFont findfont} def

  /SetFont { % string integer --
    dup /GetFontSize exch def
    exch cvlit ISOLatin1 exch scalefont setfont
  }

  /SetPlainFont { % string integer --
    dup /GetFontSize exch def
    exch cvlit findfont exch scalefont setfont
  }

  /StringSize { % string|array -- width height
    gsave
      newpath 0 0 moveto
      %dup type /stringtype eq {false charpath} {/Show {false charpath} def {exec} forall} ifelse
      /Show {false charpath} bind def dup type /stringtype eq {Show} {{exec} forall} ifelse
      pathbbox
    grestore
    4 1 roll exch 4 -1 roll
    sub abs
    3 1 roll
    sub abs
    exch
  }

  /Print { % cx cy s --
    3 1 roll CoordsToScreen
    moveto show
  }
>> def
