% PostScript Library
% Complex ProcSet
% written and copyright (c) 2006 by Andreas Zoellner

/Complex <<
  /i [0 1]
  /-i [0 -1]
  /pi 3.141592653589793238462643383279
  /e 2.71828182845904

  /Real { % c -- r
    aload pop pop
  }

  /Imag { % c -- r
    aload pop exch pop
  }

  /Unpack { % c -- cr ci
    aload pop
  }

  /Pack { % cr ci -- c
    2 array astore
  }

  /Cvs { % c -- s
    dup Abs 0 eq {
      pop (0)
    }
    {
      aload pop
      /Result 45 string def
      exch
      dup 0 eq {
        pop 0
      }
      {
        20 string cvs dup
        Result copy pop
        length
      } ifelse
      exch
      dup 0 ne {
        dup 0 ge {
          1 index 0 ne {
            Result 2 index (+) putinterval exch 1 add exch
          } if
        } if
        dup abs 1 ne {
          20 string cvs
          exch dup 3 -1 roll
          dup length 4 1 roll
          Result 3 1 roll putinterval
          add
        }
        {
          -1 eq {
            Result 1 index (-) putinterval 1 add
          } if
        } ifelse
        dup Result exch (i) putinterval 1 add
      }
      {
        pop
      } ifelse
      Result 0 3 -1 roll getinterval
    } ifelse
  }

  /RealToComplex { % r -- c
    0 2 array astore
  }

  /Abs { % c -- r
    aload pop
    dup mul exch dup mul add sqrt
  }

  /AbsSqr { % c -- r
    aload pop
    dup mul exch dup mul add
  }

  /DegToRad { % r -- r
    pi mul 180 div
  }

  /RadToDeg { % r -- r
    180 mul pi div
  }

  /Arg { % c -- r
    dup Abs 0 eq {
      pop 0
    }
    {
      aload pop exch atan DegToRad
    } ifelse
  }

  /ComplexToPolar { % c -- r phi
    dup Abs exch Arg
  }

  /PolarToComplex { % r phi -- c
    RadToDeg
    2 copy cos mul 3 1 roll sin mul
    2 array astore
  }

  /Conj { % c -- c
    aload pop
    neg
    2 array astore
  }

  /Neg { % c -- c
    aload pop
    neg exch neg exch
    2 array astore
  }

  /Ceiling { % c -- c
    aload pop
    ceiling exch ceiling exch
    2 array astore
  }

  /Floor { % c -- c
    aload pop
    floor exch floor exch
    2 array astore
  }

  /Round { % c -- c
    aload pop
    round exch round exch
    2 array astore
  }

  /Truncate { % c -- c
    aload pop
    truncate exch truncate exch
    2 array astore
  }

  /Add { % c1 c2 -- c
    aload pop 3 -1 roll aload pop
    3 -1 roll add 3 1 roll add exch
    2 array astore
  }

  /Sub { % c1 c2 -- c
    aload pop 3 -1 roll aload pop
    3 -1 roll sub 3 1 roll sub neg exch
    2 array astore
  }

  /Mul { % c1 c2 -- c
    aload pop 3 -1 roll aload pop
    4 copy
    3 -1 roll mul 3 1 roll mul sub neg
    5 1 roll
    4 1 roll mul 3 1 roll mul add
    2 array astore
  }

  /MulReal { % c r -- c
    exch aload pop
    2 index mul 3 1 roll mul exch
    2 array astore
  }

  /MulImag { % c r -- c
    exch aload pop
    2 index mul neg 3 1 roll mul
    2 array astore
  }

  /MulI { % c -- c
    aload pop
    neg exch
    2 array astore
  }

  /Div { % c1 c2 -- c
    %dup Conj exch Abs 3 1 roll Mul
    %Conj dup Abs DivReal Mul
    Conj dup Abs 3 1 roll Mul
    aload pop
    2 index div 3 1 roll exch div exch
    2 array astore
  }

  /DivReal { % c r -- c
    exch aload pop
    2 index div 3 1 roll exch div exch
    2 array astore
  }

  /DivImag { % c r -- c
    exch aload pop
    2 index div 3 1 roll exch div neg
    2 array astore
  }

  /Sqr { % c -- c
    aload pop
    2 copy
    dup mul exch dup mul sub neg
    3 1 roll
    mul 2 mul
    2 array astore
  }

  /Sqrt { % c -- c
    ComplexToPolar
    2 div exch sqrt exch
    PolarToComplex
  }

  /Exp { % c -- c
    aload pop
    exch e exch exp exch PolarToComplex
  }

  /Ln { % c -- c
    ComplexToPolar exch ln exch
    2 array astore
  }

  /Pow { % cb ce -- c
    exch Ln Mul Exp
  }

  /PowReal { % c r -- c
    exch ComplexToPolar
    2 index mul 3 1 roll exch exp exch
    PolarToComplex
  }

  /Sin { % c -- c
    % sin(z) = (exp(iz)-exp(-iz))/(2i)
    MulI dup Exp exch Neg Exp Sub 2 DivImag
  }

  /Cos { % c -- c
  }

>> def
